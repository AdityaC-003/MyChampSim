
#include "cache.h"
#include "ooo_cpu.h"
#include <unordered_map>
#include <stdlib.h>
#include <bitset>

using namespace std;

typedef uint64_t Addr_t;
#define vout cout

constexpr int LOG2_LLC_SET = log2(LLC_SET); // 11
constexpr int LOG2_LLC_SIZE = LOG2_LLC_SET + log2(LLC_WAY) + LOG2_BLOCK_SIZE;
// 11+4+6 = 21
constexpr int LOG2_SAMPLED_SETS = LOG2_LLC_SIZE - 16; // 5

constexpr int HISTORY = 8;
constexpr int GRANULARITY = 8;

constexpr int INF_RD = LLC_WAY * HISTORY - 1;
constexpr int INF_ETR = (LLC_WAY * HISTORY / GRANULARITY) - 1;
constexpr int MAX_RD = INF_RD - 22;

constexpr int SAMPLED_CACHE_WAYS = 5;
constexpr int LOG2_SAMPLED_CACHE_SETS = 4;
constexpr int SAMPLED_CACHE_TAG_BITS = 31 - LOG2_LLC_SIZE;
constexpr int PC_SIGNATURE_BITS = LOG2_LLC_SIZE - 10;
constexpr int TIMESTAMP_BITS = 8;

constexpr double TEMP_DIFFERENCE = 1.0 / 16.0;
constexpr double FLEXMIN_PENALTY = 2.0 - log2(NUM_CPUS) / 4.0;

// new additions

constexpr int WEIGHT_TABLES = 3;
constexpr int NUM_WEIGHTS = 4096;
constexpr int TRACE_BITS = 16;
constexpr int SAMPLER_ASSOC = 12;
constexpr int SATURATION_COUNTER = 4;
constexpr int THRESHOLD = 12;

const bitset<TRACE_BITS> global_hash[3] = {0x2F75, 0x9FCF, 0xF0D5};

uint32_t dbp_decisions = 0;
uint32_t mockingjay_decisions = 0;
uint32_t invalid_block_decisions = 0;
uint32_t non_writeback_decisions = 0;

uint32_t sampler_misses = 0;
uint32_t num_mock_upd = 0;
uint32_t num_invalid = 0;
uint32_t num_dbp = 0;

map<uint32_t, uint32_t> dbp_count;

// new additions end

int etr[LLC_SET][LLC_WAY];
int etr_clock[LLC_SET];

// map index = hashed pc signature
unordered_map<uint32_t, int> rdp;

int current_timestamp[LLC_SET];

struct SampledCacheLine
{
    bool valid;
    uint64_t tag;
    uint64_t signature;
    int timestamp;
};

// map index = block address
unordered_map<uint32_t, SampledCacheLine *> sampled_cache;

bool is_sampled_set(int set)
{
    int mask_length = LOG2_LLC_SET - LOG2_SAMPLED_SETS;
    int mask = (1 << mask_length) - 1;
    return (set & mask) == ((set >> (LOG2_LLC_SET - mask_length)) & mask);
}

uint64_t CRC_HASH(uint64_t _blockAddress)
{
    static const unsigned long long crcPolynomial = 3988292384ULL;
    unsigned long long _returnVal = _blockAddress;
    for (unsigned int i = 0; i < 3; i++)
        _returnVal = ((_returnVal & 1) == 1) ? ((_returnVal >> 1) ^ crcPolynomial) : (_returnVal >> 1);
    return _returnVal;
}

uint64_t get_pc_signature(uint64_t pc, bool hit, bool prefetch, uint32_t core)
{
    if (NUM_CPUS == 1)
    {
        pc = pc << 1;
        if (hit)
        {
            pc = pc | 1;
        }
        pc = pc << 1;
        if (prefetch)
        {
            pc = pc | 1;
        }
        pc = CRC_HASH(pc);
        pc = (pc << (64 - PC_SIGNATURE_BITS)) >> (64 - PC_SIGNATURE_BITS);
    }
    else
    {
        pc = pc << 1;
        if (prefetch)
        {
            pc = pc | 1;
        }
        pc = pc << 2;
        pc = pc | core;
        pc = CRC_HASH(pc);
        pc = (pc << (64 - PC_SIGNATURE_BITS)) >> (64 - PC_SIGNATURE_BITS);
    }
    return pc;
}

uint32_t get_sampled_cache_index(uint64_t full_addr)
{
    full_addr = full_addr >> LOG2_BLOCK_SIZE;
    full_addr = (full_addr << (64 - (LOG2_SAMPLED_CACHE_SETS + LOG2_LLC_SET))) >> (64 - (LOG2_SAMPLED_CACHE_SETS + LOG2_LLC_SET));
    return full_addr;
}

uint64_t get_sampled_cache_tag(uint64_t x)
{
    x >>= LOG2_LLC_SET + LOG2_BLOCK_SIZE + LOG2_SAMPLED_CACHE_SETS;
    x = (x << (64 - SAMPLED_CACHE_TAG_BITS)) >> (64 - SAMPLED_CACHE_TAG_BITS);
    return x;
}

int search_sampled_cache(uint64_t blockAddress, uint32_t set)
{
    SampledCacheLine *sampled_set = sampled_cache[set];
    for (int way = 0; way < SAMPLED_CACHE_WAYS; way++)
    {
        if (sampled_set[way].valid && (sampled_set[way].tag == blockAddress))
        {
            return way;
        }
    }
    return -1;
}

void detrain(uint32_t set, int way)
{
    SampledCacheLine temp = sampled_cache[set][way];
    if (!temp.valid)
    {
        return;
    }

    if (rdp.count(temp.signature))
    {
        rdp[temp.signature] = min(rdp[temp.signature] + 1, INF_RD);
    }
    else
    {
        rdp[temp.signature] = INF_RD;
    }
    sampled_cache[set][way].valid = false;
}

// *******************************************************************************************

typedef struct
{
    bool reuse_bit;
    bitset<4> lru;
    int LRUstackposition;
} LineReplacementState;

struct sampler
{
    bool valid;
    bitset<4> lru;
    Addr_t trace;
    bool reuse;
    bitset<TRACE_BITS> partial_tag;
    int32_t sampler_etr;
}; // Jimenez's structures

unordered_map<uint32_t, sampler *> sampler_sets;
LineReplacementState **repl = NULL;
unsigned int weight_table[WEIGHT_TABLES][NUM_WEIGHTS];

void db_initialize_replacement()
{
    // create state for sets, then for ways
    repl = new LineReplacementState *[LLC_SET];
    assert(repl);

    // create state for sets
    for (u_int32_t setIndex = 0; setIndex < LLC_SET; setIndex++)
    {
        repl[setIndex] = new LineReplacementState[LLC_WAY];
        for (u_int32_t wayIndex = 0; wayIndex < LLC_WAY; wayIndex++)
        {
            repl[setIndex][wayIndex].reuse_bit = false;
            repl[setIndex][wayIndex].lru = wayIndex;
            repl[setIndex][wayIndex].LRUstackposition = wayIndex;
        }
    }

    // Initialize the sampler_set map
    // vout << "Initializing sampler sets" << endl;
    for (uint32_t set = 0; set < LLC_SET; set++)
    {
        if (is_sampled_set(set))
        {
            // vout << "set " << set << " is sampled" << endl;
            sampler_sets[set] = new sampler[SAMPLER_ASSOC];
            for (int j = 0; j < SAMPLER_ASSOC; j++)
            {
                sampler_sets[set][j].lru = j;
                sampler_sets[set][j].partial_tag = 0;
                sampler_sets[set][j].valid = false;
                sampler_sets[set][j].reuse = false;
                sampler_sets[set][j].trace = 0;
                sampler_sets[set][j].sampler_etr = INF_ETR;
            }
        }
    }
    // vout << "Done initializing sampler sets" << endl;

    // weight tables for dead block prediction (2 bit counters)
    for (int i = 0; i < WEIGHT_TABLES; i++)
    {
        for (int j = 0; j < NUM_WEIGHTS; j++)
        {
            weight_table[i][j] = 0;
        }
    }
}

/* initialize cache replacement state */
void CACHE::llc_initialize_replacement()
{
    // put your own initialization code here
    for (int i = 0; i < LLC_SET; i++)
    {
        etr_clock[i] = GRANULARITY;
        current_timestamp[i] = 0;
    }
    for (uint32_t set = 0; set < LLC_SET; set++)
    {
        if (is_sampled_set(set))
        {
            int modifier = 1 << LOG2_LLC_SET;
            int limit = 1 << LOG2_SAMPLED_CACHE_SETS;
            for (int i = 0; i < limit; i++)
            {
                sampled_cache[set + modifier * i] = new SampledCacheLine[SAMPLED_CACHE_WAYS]();
            }
        }
    }

    // dead block prediction datastructure initialization
    db_initialize_replacement();
    // vout << "Initialization Success!" << endl;
}

///////////////////////////////////////////////////////////////
//
// Helper functions for LRU-based dead block prediction replacement policy
//
///////////////////////////////////////////////////////////////

bitset<TRACE_BITS> Hash(bitset<TRACE_BITS> hash, bitset<TRACE_BITS> trace)
{
    for (int i = 0; i < 16; i++)
    {
        hash ^= ((hash.to_ulong() << 5) + trace[i] + (hash.to_ulong() >> 2));
    }
    return hash;
}

bitset<TRACE_BITS> *compute_traces(uint64_t PC)
{
    bitset<TRACE_BITS> *hashed_traces = new bitset<TRACE_BITS>[WEIGHT_TABLES];
    bitset<TRACE_BITS> mask_16 = (1 << TRACE_BITS) - 1;
    bitset<TRACE_BITS> trace = PC & mask_16.to_ulong();

    for (int i = 0; i < WEIGHT_TABLES; i++)
    {
        hashed_traces[i] = Hash(global_hash[i], trace);
        // trace = hashed_traces[i];
    }
    return hashed_traces;
}

int db_predict(const bitset<TRACE_BITS> *traces)
{
    // returns false if dead, true if alive
    // false - will NOT be reused, true - will be reused
    int output = 0;
    bitset<12> mask = (1 << 12) - 1;

    for (int i = 0; i < WEIGHT_TABLES; i++)
    {
        unsigned int index = traces[i].to_ulong() & mask.to_ulong();
        if (index > NUM_WEIGHTS)
            cout << "trace[" << i << "]: " << index << "\n";
        output += weight_table[i][index];
        // vout << "WT[" << i << "][" << index << "]: " << weight_table[i][index] << "\n";
    }

    dbp_count[output]++;
    return (output >= THRESHOLD ? false : true);
}

void db_train(const bitset<TRACE_BITS> *traces, bool increment)
{
    bitset<12> mask_12 = ((1 << (int)(log2(NUM_WEIGHTS))) - 1);
    if (increment == false)
    {
        for (int i = 0; i < WEIGHT_TABLES; i++)
        {
            unsigned int index = traces[i].to_ulong() & mask_12.to_ulong();
            int weight = weight_table[i][index];
            weight_table[i][index] = (weight > 0) ? (weight - 1) : 0;
            // vout << "weight_table[" << i << "][" << index << "]: " << weight_table[i][index] << "\n";
        }
    }
    else if (increment)
    {
        for (int i = 0; i < WEIGHT_TABLES; i++)
        {
            unsigned int index = traces[i].to_ulong() & mask_12.to_ulong();
            int weight = weight_table[i][index];
            weight_table[i][index] = (weight < SATURATION_COUNTER) ? (weight + 1) : SATURATION_COUNTER;
            // vout << "weight_table[" << i << "][" << index << "]: " << weight_table[i][index] << "\n";
        }
    }
}

int32_t get_dbp_victim(uint32_t set, uint64_t pc, uint32_t type)
{
    int32_t victim_way = -1;
    bitset<TRACE_BITS> *traces = compute_traces(pc);
    bool prediction = db_predict(traces);

    if (prediction == false and type != WRITEBACK)
    {
        return LLC_WAY;
    }
    else if (prediction == true)
    {
        // search the set for dead blocks
        int max_etr = -1;
        for (unsigned int way = 0; way < LLC_WAY; way++)
        {
            if (repl[set][way].reuse_bit == false)
            {
                if (abs(etr[set][way]) > max_etr ||
                    (abs(etr[set][way]) == max_etr &&
                     etr[set][way] < 0))
                {
                    max_etr = abs(etr[set][way]);
                    victim_way = way;
                }
            }
        }
    }
    return victim_way;
}

uint32_t get_LRU_victim(uint32_t set)
{
    uint32_t victim_way = 0;
    for (uint32_t way = 0; way < LLC_WAY; way++)
    {
        if (repl[set][way].LRUstackposition == LLC_WAY - 1)
        {
            victim_way = way;
            break;
        }
    }
    return victim_way;
}

/* find a cache block to evict
 * return value should be 0 ~ 15 (corresponds to # of ways in cache)
 * current_set: an array of BLOCK, of size 16 */
uint32_t CACHE::llc_find_victim(uint32_t cpu, uint64_t instr_id,
                                uint32_t set, const BLOCK *current_set,
                                uint64_t pc, uint64_t full_addr, uint32_t type)
{
    /* don't modify this code or put anything above it;
     * if there's an invalid block, we don't need to evict any valid ones */
    for (int way = 0; way < LLC_WAY; way++)
    {
        if (current_set[way].valid == false)
        {
            invalid_block_decisions++;
            return way;
        }
    }

    // dead block prediction goes here
    int dbp_victim = get_dbp_victim(set, pc, type);
    if (dbp_victim != -1 && dbp_victim != LLC_WAY)
    {
        dbp_decisions++;
        return dbp_victim;
    }

    // your eviction policy goes here

    // Mockingjay
    int max_etr = 0;
    int victim_way = 0;
    for (int way = 0; way < LLC_WAY; way++)
    {
        if (abs(etr[set][way]) > max_etr ||
            (abs(etr[set][way]) == max_etr &&
             etr[set][way] < 0))
        {
            max_etr = abs(etr[set][way]);
            victim_way = way;
        }
    }

    // mockingjay_decisions++;
    // return lru_victim(cpu, instr_id, set, current_set, 1, full_addr, type);

    uint64_t pc_signature = get_pc_signature(pc, false, type == PREFETCH, cpu);
    if (type != WRITEBACK && rdp.count(pc_signature) &&
        (rdp[pc_signature] > MAX_RD || rdp[pc_signature] / GRANULARITY > max_etr))
    {
        non_writeback_decisions++;
        return LLC_WAY;
    }

    mockingjay_decisions++;
    return victim_way;
}

int temporal_difference(int init, int sample)
{
    if (sample > init)
    {
        int diff = sample - init;
        diff = diff * TEMP_DIFFERENCE;
        diff = min(1, diff);
        return min(init + diff, INF_RD);
    }
    else if (sample < init)
    {
        int diff = init - sample;
        diff = diff * TEMP_DIFFERENCE;
        diff = min(1, diff);
        return max(init - diff, 0);
    }
    else
    {
        return init;
    }
}

void update_LRU_state(const int index, const int way)
{
    unsigned int lru_position = sampler_sets[index][way].lru.to_ulong();

    for (int i = 0; i < SAMPLER_ASSOC; i++)
    {
        if (sampler_sets[index][i].lru.to_ulong() < lru_position)
        {
            sampler_sets[index][i].lru = sampler_sets[index][i].lru.to_ulong() + 1;
        }
    }

    sampler_sets[index][way].lru = 0;
}

int get_LRU_index(const int index)
{
    int way = 0;
    for (int i = 0; i < SAMPLER_ASSOC; i++)
    {
        if (sampler_sets[index][i].lru.to_ulong() == LLC_WAY - 1)
        {
            way = i;
            break;
        }
    }
    return way;
}

int get_etr_index(const int index)
{
    int way = -1;
    for (int i = 0; i < LLC_WAY; i++)
    {
        if (abs(etr[index][i]) == INF_ETR)
        {
            way = i;
            break;
        }
    }
    return way;
}

int increment_timestamp(int input)
{
    input++;
    input = input % (1 << TIMESTAMP_BITS);
    return input;
}

int time_elapsed(int global, int local)
{
    if (global >= local)
    {
        return global - local;
    }
    global = global + (1 << TIMESTAMP_BITS);
    return global - local;
}

void print_sampler_sets()
{
    for (auto x : sampler_sets)
    {
        cout << "sampler set details" << endl;
        cout << "set index: " << x.first << endl;
        sampler *block = x.second;
        cout << "partial tag: " << block->partial_tag << endl;
        cout << "lru: " << block->lru << endl;
        cout << "reuse bit: " << block->reuse << endl;
        cout << "trace: " << block->trace << endl;
        cout << "valid: " << block->valid << endl;
        cout << "********" << endl;
    }
}

void update_dbp_replacement_state(uint32_t cpu, uint32_t set,
                                  uint32_t way, uint64_t full_addr,
                                  uint64_t pc, uint64_t victim_addr,
                                  uint32_t type, uint8_t hit)
{
    if (is_sampled_set(set))
    {
        uint32_t sampled_cache_index = set;
        uint64_t sampled_cache_tag = get_sampled_cache_tag(full_addr);
        bool block_exists = false;
        for (int i = 0; i < SAMPLER_ASSOC; i++)
        {
            if ((sampler_sets[sampled_cache_index][i].partial_tag == sampled_cache_tag) && (sampler_sets[sampled_cache_index][i].valid))
            {
                bitset<TRACE_BITS> *traces = compute_traces(sampler_sets[sampled_cache_index][i].trace);
                db_train(traces, false);
                block_exists = true;
                sampler_sets[sampled_cache_index][i].trace = pc;
                update_LRU_state(sampled_cache_index, i);
                traces = compute_traces(pc);
                sampler_sets[sampled_cache_index][i].reuse = db_predict(traces);
                sampler_sets[sampled_cache_index][i].sampler_etr = etr[set][way];
                break;
            }
        }

        if (!block_exists)
        {
            sampler_misses++;
            int my_way = -1;

            // look for an invalid block
            for (int i = 0; i < SAMPLER_ASSOC; i++)
            {
                if (sampler_sets[sampled_cache_index][i].valid == false)
                {
                    my_way = i;
                    num_invalid++;
                    break;
                }
            }

            // if no such block exists, evict block with highest ETR
            if (my_way == -1)
            {
                num_mock_upd++;
                int max_etr = 0;
                int victim_way = 0;
                for (int www = 0; www < SAMPLER_ASSOC; www++)
                {
                    auto val = sampler_sets[sampled_cache_index][www].sampler_etr;
                    if (abs(val) > max_etr ||
                        (abs(val) == max_etr && val < 0))
                    {
                        max_etr = abs(val);
                        victim_way = www;
                    }
                }
                my_way = max(0, victim_way);
            }

            // train
            bitset<TRACE_BITS> *traces = compute_traces(sampler_sets[sampled_cache_index][my_way].trace);
            db_train(traces, true);
            sampler_sets[sampled_cache_index][my_way].partial_tag = sampled_cache_tag;
            sampler_sets[sampled_cache_index][my_way].trace = pc;
            update_LRU_state(sampled_cache_index, my_way);
            traces = compute_traces(pc);
            sampler_sets[sampled_cache_index][my_way].reuse = db_predict(traces);
            sampler_sets[sampled_cache_index][my_way].valid = true;
            sampler_sets[sampled_cache_index][my_way].sampler_etr = etr[set][way];
        }
    }
    repl[set][way].reuse_bit = db_predict(compute_traces(pc));
}

/* called on every cache hit and cache fill */
void CACHE::llc_update_replacement_state(uint32_t cpu, uint32_t set,
                                         uint32_t way, uint64_t full_addr,
                                         uint64_t pc, uint64_t victim_addr,
                                         uint32_t type, uint8_t hit)
{

    string TYPE_NAME;
    if (type == LOAD)
        TYPE_NAME = "LOAD";
    else if (type == RFO)
        TYPE_NAME = "RFO";
    else if (type == PREFETCH)
        TYPE_NAME = "PF";
    else if (type == WRITEBACK)
        TYPE_NAME = "WB";
    else
        assert(0);

    if (hit)
        TYPE_NAME += "_HIT";
    else
        TYPE_NAME += "_MISS";

    // baseline LRU
    if (hit && (type == WRITEBACK)) // writeback hit does not update LRU state
        return;

    lru_update(set, way);

    if (type == WRITEBACK)
    {
        if (!hit)
        {
            etr[set][way] = -INF_ETR;
        }
        return;
    }

    pc = get_pc_signature(pc, hit, type == PREFETCH, cpu);

    if (is_sampled_set(set))
    {
        uint32_t sampled_cache_index = get_sampled_cache_index(full_addr);
        uint64_t sampled_cache_tag = get_sampled_cache_tag(full_addr);
        int sampled_cache_way = search_sampled_cache(sampled_cache_tag, sampled_cache_index);

        if (sampled_cache_way > -1)
        {
            uint64_t last_signature = sampled_cache[sampled_cache_index][sampled_cache_way].signature;
            uint64_t last_timestamp = sampled_cache[sampled_cache_index][sampled_cache_way].timestamp;
            int sample = time_elapsed(current_timestamp[set], last_timestamp);

            if (sample <= INF_RD)
            {
                if (type == PREFETCH)
                {
                    sample = sample * FLEXMIN_PENALTY;
                }
                if (rdp.count(last_signature))
                {
                    int init = rdp[last_signature];
                    rdp[last_signature] = temporal_difference(init, sample);
                }
                else
                {
                    rdp[last_signature] = sample;
                }

                sampled_cache[sampled_cache_index][sampled_cache_way].valid = false;
            }
        }

        int lru_way = -1;
        int lru_rd = -1;
        for (int w = 0; w < SAMPLED_CACHE_WAYS; w++)
        {
            if (sampled_cache[sampled_cache_index][w].valid == false)
            {
                lru_way = w;
                lru_rd = INF_RD + 1;
                continue;
            }

            uint64_t last_timestamp = sampled_cache[sampled_cache_index][w].timestamp;
            int sample = time_elapsed(current_timestamp[set], last_timestamp);
            if (sample > INF_RD)
            {
                lru_way = w;
                lru_rd = INF_RD + 1;
                detrain(sampled_cache_index, w);
            }
            else if (sample > lru_rd)
            {
                lru_way = w;
                lru_rd = sample;
            }
        }
        detrain(sampled_cache_index, lru_way);

        for (int w = 0; w < SAMPLED_CACHE_WAYS; w++)
        {
            if (sampled_cache[sampled_cache_index][w].valid == false)
            {
                sampled_cache[sampled_cache_index][w].valid = true;
                sampled_cache[sampled_cache_index][w].signature = pc;
                sampled_cache[sampled_cache_index][w].tag = sampled_cache_tag;
                sampled_cache[sampled_cache_index][w].timestamp = current_timestamp[set];
                break;
            }
        }

        current_timestamp[set] = increment_timestamp(current_timestamp[set]);
    }

    if (etr_clock[set] == GRANULARITY)
    {
        for (int w = 0; w < LLC_WAY; w++)
        {
            if ((uint32_t)w != way && abs(etr[set][w]) < INF_ETR)
            {
                etr[set][w]--;
            }
        }
        etr_clock[set] = 0;
    }
    etr_clock[set]++;

    if (way < LLC_WAY)
    {
        if (!rdp.count(pc))
        {
            if (NUM_CPUS == 1)
            {
                etr[set][way] = 0;
            }
            else
            {
                etr[set][way] = INF_ETR;
            }
        }
        else
        {
            if (rdp[pc] > MAX_RD)
            {
                etr[set][way] = INF_ETR;
            }
            else
            {
                etr[set][way] = rdp[pc] / GRANULARITY;
            }
        }
    }

    // vout << "Calling update_dbp_replacement_state()" << endl;
    update_dbp_replacement_state(cpu, set,
                                 way, full_addr,
                                 pc, victim_addr,
                                 type, hit);
}

/* called at the end of the simulation */
void CACHE::llc_replacement_final_stats()
{
    cout << endl;
    cout << "Invalid block evictions: " << invalid_block_decisions << endl;
    cout << "DBP Decisions: " << dbp_decisions << endl;
    cout << "Mockingjay Decisions: " << mockingjay_decisions << endl;
    cout << "Non Writeback Decisions: " << non_writeback_decisions << endl;
    cout << endl;
    cout << "DB Predictions at the end: " << endl;
    for (auto x : dbp_count)
    {
        cout << x.first << " " << x.second << endl;
    }
    cout << endl;
    cout << "Sampler Misses: " << sampler_misses << endl;
    cout << "Mockingjay Updates within sampler sets: " << num_mock_upd << endl;
    cout << "Invalid Block Updates within sampler sets: " << num_invalid << endl;
    cout << "DBP Updates within sampler sets: " << num_dbp << endl;
}

// *******************************************************************************************
